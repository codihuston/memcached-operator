# Purpose

This repository will contain some patterns that I've found useful for developing
go-based operators for OLM using the operator-sdk that will eventually need to
be certified by Red Hat.

## The Problem with Bundling

When building a bundle that will need to undergo the certification process
from Red Hat prior to publishing, it appears that there are several "things"
that need to be done post-bundling in order to "complete" a bundle, such that
it will pass certification. Scenarios that I've encountered that require manual
tweaks post-bundling are as follows:

> Important: the bundle process should be idempotent, so any hacks (if needed)
> should always produce the same exact output. Consider cases where there are
> errors. This is why we opt to leverage the kustomize files over templating
> in the base manifests directly with `sed` (since that would entail maintaining
> original state of the base `ClusterServiceVersion` and potentially other
> manifests). Remember that commands like `make manifests` can cause overwrites
> to the base manifests as well!

> Note: that this does not include any remarks centered around [Scorecard Testing](https://docs.openshift.com/container-platform/4.8/operators/operator_sdk/osdk-scorecard.html),
> which is also used during the certification process.

1. In the `ClusterServiceVersion`, you must have a:
    1. `spec.replaces`: if your operator will replace an old version, you'll
    definitely want to have this
    1. `metadata.annotations.olm.skipRange: '>=1.0.0 <2.0.0'`: if your operator
    will replace more than one version, you'll want to specify
    [olm.skipRange](https://github.com/operator-framework/operator-lifecycle-manager/blob/master/doc/design/how-to-update-operators.md#skiprange)
    1. `spec.relatedImages`: a list of objects containing a name and image
    that is referenced using image digest pinning (`SHA256`)

        > Important: it appears that an image digest is not generated until an
        > image is either push/pulled to a Docker v2 registry. So before a
        > bundle can be 100% completed, the images must be published somewhere.
        > [Docker Image Manifest v2](https://docs.docker.com/registry/spec/manifest-v2-2/)
        > enables the exact same image to be comparable between different v2
        > registries. These manifests are only generated when an image is
        > stored in said registry.

        Since we are already using digest pinning, you may
        be interested in supporting "disconnected mode" for clusters on
        restricted networks. See `operators.openshift.io/infrastructure-features`
        under [Operator Metadata Annotations](https://docs.openshift.com/container-platform/4.9/operators/operator_sdk/osdk-generating-csvs.html#osdk-csv-manual-annotations_osdk-generating-csvs).
        The example provided in this repo enables this by default by
        hard-coding it into the [base CSV manifest](./config/manifests/bases/memcached-operator.clusterserviceversion.yaml).

    1. If your operator creates multiple sub-resources (say, pods/deployments),
    you may opt to allow end-users to override the image paths for these. If
    this is the case, and you want to keep these image paths out of the go
    source code, you can override them with kustomize under `config/samples`.
    Samples are injected into `metadata.annotations.alm-examples` during the
    bundle process by presumably operator-sdk behind-the-scenes. By default,
    it seems the first object in that list of examples is auto-populated in the
    OpenShift Web GUI when creating your `CustomResource`

        This repo doesn't include an example, but the approach to doing this
        would be the same as how the `bin/bundle` script injects these
        into the base CSV, but instead you'd have another target in the
        kustomization template, or a standalone template under `config/samples`.

1. In the `bundle/metadata/annotations.yaml` file.
    1. A label for `com.redhat.openshift.versions: 4.6-4.9`, where you specify
    a range of version that this operator release supports. Typically,
    publishing a bundle consists of publishing your bundle contents in a PR
    forked from [Red Hat's Certified Operator repo](https://github.com/redhat-openshift-ecosystem/certified-operators),
    meaning you don't need to build the bundle docker image yourself. However,
    in case you do (and this image will be used in a certification process),
    you need to be sure that this label is added to the `bundle.Dockerfile`
    which is generated by the `make bundle` command. That is, this file should
    be in sync with the aforementioned annotations file.


This repo attempts to automate these things as cleanly as possible.

You can read more about [manually-defined CSV fields](https://docs.openshift.com/container-platform/4.9/operators/operator_sdk/osdk-generating-csvs.html#osdk-manually-defined-csv-fields_osdk-generating-csvs)
as well as optional and generated CSV fields.


## Solution: Dynamic Injection of Fields and Values into Bundle Manifests

The `bin/bundle` script will use a kustomization template to dynamically
write values into a base manifest, such that it is included in the
bundle generated by the operator-sdk. Most of these tweaks are done directly to
the base `ClusterServiceVersion` manifest.

This is script a proof-of-concept that defines a pattern one might
use if they wish to inject a image digest (`SHA256`) into a `spec.relatedImages`
or the controller/manager deployment image which is recommended in the
[Red Hat OpenShift Certification Process](https://github.com/redhat-openshift-ecosystem/certification-releases/blob/main/4.9/ga/troubleshooting.md#digest-pinning),
along with other fields that are deemed significant to the certification
process as discussed in the previous section.
